---
layout:     post
title:      "什么是并查集"
subtitle:   " \"What is Union Find Set\""
date:       2020-08-14 10:23:45
author:     "Durant"
latex: true
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
   - 并查集
   - 被Oiers视作优雅的算法    
---



# 什么是并查集

并查集被许多$OIers$认为是简洁而高雅的数据结构之一，主要用于解决一些**元素分组**的问题，它管理一系列**不相交**的集合，并支持两种操作。

- **合并**（Union）：把两个不相交的集合合并为一个集合
- **查询**（Find）：查询两个元素是否在同一个集合之中

在连通性问题中（如岛屿问题），并查集很有作用。**核心思想**是连通区域内所有点的根节点其实是同一个。将每个点映射为一个数字。先假设每个点的根节点就是它们自己，然后我们以此输入连通的点对，然后将其中一个点的根节点赋给另一个点的根节点，这样两个点所在的连通区域又相互连通了。

好的我们一步一步来画板子（ddrdd）：

并查集的主要操作有：

- `find(int m)` :查找$m$的根节点
- `isConnected(int m, int n)`：判断$m,n$两个点是否在同一个连通区域。
- `Union(int m, int n)`:合并$m,n$两个点所在的连通区域。



**初始化**

```C++
int fa[MAXN];
inline void init (int n )
{
    for(int i = 0; i <= n;i++)
        fa[i] = i;
}
```

**查询**

```C++
int find(int x)
{
    if(fa[x]==x)
        return x;
    else 
        return find(fa[x]);
}

```

一层一层访问父节点，直至根节点（根节点的标志就是父节点是本身）。要判断两个元素是否属于同一个集合，只需要看它们的根节点是否相同即可。

**合并**

```C++
inline void merge(int i, int j)
{
	fa[find(i)] = find(i);
}
```

合并操作也是很简单的，先找到两个集合的代表元素，然后将前者的父节点设为后者即可。当然也可以将后者的父节点设为前者.



---

初级并查集效率较低，我们需要进行**路径压缩**。

我们添加元素可能会形成长链，想要从底部寻找根节点会越来越难。路径压缩是这样一种算法，每个元素到根节点的路径尽可能短。

我们可以在查找的过程中，<u>把沿途每个节点的父节点都设为根节点</u>。

**路径压缩后合并**

```C++
int find(int x)
{
    return x==find(x)? x : (fa[x] = find(fa[x]));
}
```



![img](https://picb.zhimg.com/80/v2-cca3ddf5806a221201ed78caf1d27041_720w.jpg)

我们得到的并查集是这样的，很像一棵二叉树。